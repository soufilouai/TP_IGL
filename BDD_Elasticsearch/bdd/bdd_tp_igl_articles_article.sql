-- MySQL dump 10.13  Distrib 8.0.34, for Win64 (x86_64)
--
-- Host: 127.0.0.1    Database: bdd_tp_igl
-- ------------------------------------------------------
-- Server version	8.0.35

/*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
/*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
/*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
/*!50503 SET NAMES utf8 */;
/*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
/*!40103 SET TIME_ZONE='+00:00' */;
/*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
/*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
/*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
/*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;

--
-- Table structure for table `articles_article`
--

DROP TABLE IF EXISTS `articles_article`;
/*!40101 SET @saved_cs_client     = @@character_set_client */;
/*!50503 SET character_set_client = utf8mb4 */;
CREATE TABLE `articles_article` (
  `id` bigint NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `summary` longtext NOT NULL,
  `keywords` varchar(255) NOT NULL,
  `content` text CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci,
  `pdf` varchar(255) NOT NULL,
  `date` datetime(6) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=102 DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_0900_ai_ci;
/*!40101 SET character_set_client = @saved_cs_client */;

--
-- Dumping data for table `articles_article`
--

LOCK TABLES `articles_article` WRITE;
/*!40000 ALTER TABLE `articles_article` DISABLE KEYS */;
INSERT INTO `articles_article` VALUES (96,'ashfsdfsdufhsdfgs','sdfsdgdfgsdfgsd','sdgsdfgsgsfgsd','sdfgdfgdfgdfg','d','2023-12-12 00:00:00.000000'),(97,'xcvxcvxc','xcvxcvxcv','xcvxcvbxc','xcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggddddddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffxcvfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggddddddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggddddddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggddddddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddggdddddddddddddddggddddddddddddddddddggdddddddddddddddggffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggddddddddddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdddddddddddddddddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddddddddggdddddddddddddddddddddddddddddddddddddggdddddddddddddddggddddddddddddddddddggdddddddddddddddggfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddxcvffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggdfdsfsgfsdhgfhgsdfhgsdhfgsdhfggdhgggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggddddddddddddddddddddddddddddddddddd','dsfsdf','2022-12-12 00:00:00.000000'),(98,'AI Model for Computer games based on Case Based Reasoning and AI Planning','Making efficient AI models for games with imperfect information can be a particular challenge. Considering the large number of possible moves and the incorporated uncertainties building game trees for these games becomes very difficult due to the exponential growth of the number of nodes at each level. This effort is focused on presenting a method of combined Case Based Reasoning (CBR) with AI Planning which drastically reduces the size of game trees. Instead of looking at all possible combinations we can focus only on the moves that lead us to specific strategies in effect discarding meaningless moves. These strategies are selected by finding similarities to cases in the CBR database. The strategies are formed by a set of desired goals. The AI planning is responsible for creating a plan to reach these goals. The plan is basically a set of moves that brings the player to this goal. By following these steps and not regarding the vast number of other possible moves the model develops Game Trees which grows slower so they can be built with more feature moves restricted by the same amount of memory.','Game AI, Case Based Reasoning, AI Planning, Game Trees','AI Model for Computer games based on Case Based Reasoning and AI Planning  Vlado Menkovski Athens Information Technology 0.8km Markopoulou Ave. Peania, 19002, Greece vmen@ait.edu.gr Dimitrios Metafas Athens Information Technology 0.8km Markopoulou Ave. Peania, 19002, Greece dmeta@ait.edu.gr AbstractMaking efficient AI models for games with imperfect information can be a particular challenge. Considering the large number of possible moves and the incorporated uncertainties building game trees for these games becomes very difficult due to the exponential growth of the number of nodes at each level. This effort is focused on presenting a method of combined Case Based Reasoning (CBR) with AI Planning which drastically reduces the size of game trees. Instead of looking at all possible combinations we can focus only on the moves that lead us to specific strategies in effect discarding meaningless moves. These strategies are selected by finding similarities to cases in the CBR database. The strategies are formed by a set of desired goals. The AI planning is responsible for creating a plan to r each these goals. The plan is basically a set of moves that brings the player to this goal. By following these steps and not regarding the vast number of other possible moves the model develops Game Trees which grows slower so they can be built with more feature moves restricted by the same amount of memory.  Categories and Subject Descriptors I.2.1 [Applications and Expert Systems]: GamesGeneral TermsAlgorithms, Performance. KeywordsGame AI, Case Based Reasoning, AI Planning, Game Trees 1. Introduction The goal of this effort is to explore a model for design and implementation of an AI agent for turn based games. This model provides for building more capable computer opponents that rely on strategies that closely resemble human approach in solving problems opposed to classical computational centric heuristics in game AI. In this manner the computational resources can be focused on more sensible strategies for the game play.  With the advancement in computer hardware increasingly more computing power is left for executing AI algorithms in g a m e s .  I n  t h e  p a s t  A I  i n  g a m e s was mainly a cheating set of instructions that simulated the in creasing difficulty in the game environment so that the player had the illusion of real counterpart. Improvement in available memory and processing power allows implementation of more intelligent algorithms for building the game environment as well as direct interaction with the human players.   In this particular research the emphasis is put on the interaction between the AI agent and a computer player in the realm of the game rules. It is particularly focused on turn based games that have the elements of uncertainty like dice or concealed information. At the beginning a description of Game AI algorithms are given; such as Game Trees and Minimax. The following section describes an approach of using AI Planning to improve building Game Trees in games with imperfect information where Game Trees tend to be very large with high growth ratio. Section 4 discusses another approach that provides a significant reduction to the number of considered moves in order to find the favorable strategy of the AI player. This approach uses AI Planning techniques and Case Base Reasoning (CBR) to plan for different scenarios in predetermined strategies which would be analogous to human player experience in the particular game. The CBR database illustrates a set of past experiences for the AI problem and the AI Planning illustrates the procedure to deal with the given situation in the game. In the next two sections implementations and evaluations of both approaches are given. The AI Planning approach is implemented with the Tic-tac-toe game and the combined AI Planning and CBR approach is implemented with a model for the Monopoly game. The last part contains conclusions and future work ideas.  2. Game Trees and Minimax Game Trees are common model for evaluating how different combinations of moves from the player and his opponents will affect the future position of the player and eventually the end result of the game. An algorithm that decides on the next move by evaluating the results from the built Game Tree is minimax [1]. Minimax assumes that the player at hand will always choose the best possible move for him, in ot her words the player will try to select the move that maximizes the result of the evaluation function over the game state. So basically the player at hand needs to choose the best move overall while taking into account that the next player(s) will try to do the same thing. Minimax tries to maximize the minimum gain. Minimax can be applied to multiple Permission to make digital or hard copies of all or part of this work for personal or classroom use is granted without fee provided that copies are not made or distributed for profit or commercial advantage and that copies bear this notice and the full citation on the first page. To copy otherwise, or republish, to post on servers or to redistribute to lists, requires prior specific permission and/or a fee. DIMEA08 , September 1012, 2008, Athens, Greece. Copyright 2008 ACM 978-1-60558-248-1/08/09... $5.00 Interactive and Adaptable Media 2953rd International Conference on Digital Interactive Media in Entertainment and Artslevels of nodes on the g ame tree, where the leaves bring the final known (or considered) game state.  The minimax theorem states: For every two-person, zero-sum game there is a mixed strategy for each player, such that the expected payoff for both is the same value V when the players use these strategies. Furthermore, V is the best payoff each can expect to receive from a play of the game; that is, these mixed strategies are the optimal strategies for the two players. This theorem was established by John von Neumann, who is quoted as saying \"As far as I can see, there could be no theory of games  without that theorem  I thought there was nothing worth publishing until the Minimax Theorem  was proved\" [2]. A simple example of minimax can be observed by building a game tree of the tic-tac-toe game. The tic-tac-toe game is a simple game which can end by the first player wining, the second player wining or a tie. There are nine positions for each of the players in which at each turn the player puts X or O sign. If the player has three adjacent signs in a row, column or the two diagonals he or she wins. This game has limited number of position and it is well suited for building the whole game tree. The leaves of this tree will be final positions in the game. A heuristics evaluation function will also need to be written to evaluate the value of each node along the way. 3. AI Planning for building Game Trees 3.1.1 AI Planning AI Planning also referred as Automated Planning and Scheduling is a branch of Artificial Intelligence that focuses on finding strategies or sequences of actions that reach a predefined goal [3]. Typical execution of AI Planning algorithms is by intelligent agents, autonomous ro bots and unmanned vehicles. Opposed to classical control or classification AI Planning results with complex solutions that are derived from multidimensional space.  AI Planning algorithms are also common in the video game development. They solve broad range of problems from path finding to action planning. A typical planner takes three inputs: a description of the initial state of the world, a description of the desired goal, and a set of possible actions. Some efforts for incorporating planning techniques for building game trees have also shown up, similar to the approach explored in this effort. In addition Cased Based Reasoning [4] techniques are also gathering popularity in developing strategies based in prior knowledge about the problems in the games. One of the benefits from Hierarchical Task Network (HTN) [5] planning is the possibility to build Game Trees based on HTN plans; this met hod is described in the following section. 3.2 Game Trees with AI Planning An adaptation of the HTN planning can be used to build much smaller and more efficient game trees. This idea has already been implemented in the Bridge Baron a computer program for the game of Contact Bridge [6]. Computer programs based on Game Tree search techniques are now as good as or better than humans in many games like Chess [7] and checkers [8], but there are some difficulties in building a game tree for games that have imperfect information and added uncertainty like card or games with dice. The main problem is the enorm ous number of possibilities that the player can choose from in making his move. In addition some of the moves are accompanied with probabilities based on the random elements in the games. The number of possible moves exponentially grows with each move so the depth of the search has to be very limited to accommodate for the memory limitations.  The basic idea behind using HTN for building game trees is that the HTN provides the means of expressing high level goals and describing strategies how to reach those goals. These goals may be decomposed in goals at lower level called sub-goals. This approach closely resembles the way a human player usually addresses a complex problem. It is also good for domains where classical search for solution is no t feasible due to the vastness of the problem domain or uncertainties. 3.2.1 Hierarchical Task Networks The Hierarchical Task Network, or HTN, is an approach to automated planning in which the dependency among actions can be given in the form of networks [9] [Figure 1]. A simple task network (or just a task network for short) is an acyclic digraph /g1875/g3404/g4666 /g1847 /g481 /g1831 /g4667  in which U is the node set, E is the edge set, and each node /g1873/g1488/g1847  contains a task /g1872/g3048. The edges of /g1875define a partial ordering of U. If the partial ordering is total, then we say that /g1875 is totally ordered, in which case /g1875 can be written as a sequence of tasks /g1875/g3404 /g1731/g1872/g2869/g481/g1872/g2870/g481/g485/g481/g1872 /g3038/g1732.Figure 1: Simple Hierarchical Task Network A Simple Task Network (STN) method is a 4-tuple of its n ame, task, precondition and a task network. The name of the method lets us refer unambiguously to substitution instances of the method, without having to write the preconditions and effects explicitly. The task tells what kind of task can be applied if the preconditions are met. The preconditions specify the conditions that the current state needs to satisfy in order for the method to be applied. And the network defines the specific subtasks to accomplish in order to accomplish the task. A method is relevant for a task if the current state satisfies the preconditions of a method that implements that task. This task can be then substituted with the instance of the method. The substitution is basically giving the method network as a solution for the task. If there is a task Go home and the distance to home is 3km [Figure 2] and there exists a method walk-to and this method has a precondition that the distance is le ss than 5km, then a substation to the task Go home can be made with this method instance.  Figure 2: HTN Method Buy milkGo to (shop) Purchase Go to (home )Go-to (from, to)Walk (to)If (to  from) < 5km 296 DIMEA 20083rd International Conference on Digital Interactive Media in Entertainment and ArtsIf the distance is larger than 5km another methto be substituted [Figure 3]. Figure 3: HTN Method 2 An STN planning domain is a set of operati omethods M. A STN planning problem is a 4- tustate S 0, the task network w called initial tas kSTN domain. A plan /g2024/g3404 /g1731/g1853/g2869/g481/g485/g481/g1853 /g3041/g1732is a solut iproblem if there is a way to decompose w into and each decomposition is applicable in the a pthe world. The algorithm that is capable to networks into plans is called Total-forward- deco[9] or Partial-forward- decomposition (PFD). Hcases where one does not want to use a forw aprocedure. HTN planning is generalization of Sgives the planning procedure more fr eedo mconstruct the task networks.  In order to provide this freedom, a bookk eis needed to represent constraints that the plan nnot yet enforced. The bookkeeping is done b yunenforced constrain ts explicitly in the task net wThe HTN generalizes the definition of aSTN. A task network is the pair /g1875 /g3404  /g4666/g1847/g481 /g1829/g4667 wtask nodes and Cis a set of constraints. Eacspecifies a requirement that must be satisfied b ya solution to a planning problem.  The definition of a method in HTN als odefinition used in STN planning. A HTN pl aname, task, subtasks, and constraints. The sconstraints form the task network. The HTN pla nidentical to STN planning domains except they uinstead of STN methods. Compared to classical planners the pri mHTN planners is their sophisticated knowledge rreasoning capabilities. They can represent and non-classical planning problems; with a goo dguide them, they can solve classical planning pmagnitude more quickly than classical or neo cThe primary disadvantage of HTN is the ne eauthor to write not only a set of planning oper aof methods. 3.2.2 HTN Planning in building Game For a HTN planning algorithm to be adaptrees we need to define the domain (set of Hoperators) which is the domain of the game. Th ia knowledge representation of the rules of th eenvironments and possible strategies of game pl aIn this domain the ga me rules as well as k ntackle specific task are defined.   The imple mTree building with HTN is called Tig nimplementation uses a procedure simil adecomposition, but adapted to build up a game Drive(toIf(tGo-to (from, to) If(to  from) < 5km Walk (to) hod instance needs ons O and a set of uple of the initial k network and the ion for a planning  if  is executable ppropriate state of decompose these omposition (TFD) However there are ard-decomposition STN planning that m about how to eeping mechanism ning algorithm has y representing the work. a task network in where /g1847 is a set of h constraint in C y every plan that is o generalizes the an is a 4 -tuple of subtasks and the nning domains are use HTN methods mary advantage of representation and solve a variety of d set of HTNs to problems orders of classical planne rs. ed of the domain ators but also a set Treested to build game HTN methods and is is in some sense e game, the game ay.nown strategies to mentation of Game num2 [9]. This ar to forward-tree rather than a plan. The branches of the game tree re pthe methods. Tignum2 applies all me tstate of the world to produce ne wcontinues recursively until there are nhave not a lready been applied to t hworld.  In the task network generated by Tign uactions will occur is determined by thBy listing the actions in the order network can be serialized into a ga m4. Case Based Reasoning i n4.1 Case Based ReasoningCase-based reasoning (CBR) is a Artificial Intelligence (AI), both as problems and as a basis for standalone Case-based reasoning is a paradig msolving and learning that has became applied subfield of AI of recent ye aintuition that problems tend to recur. Iare often similar to previously e ntherefore, that past solutions may be o f[10].  CBR is particularly applicable to prob lavailable, even when the domain is nfor a deep domain model. Helpdesks ,systems have been the most successf uto determine a fault or diagnostic attributes, or to determine whether o rrepair is necessary given a set of past sFigure 5: Game Tree built f rFigure 4 : HTN to Game T r)to  from) < 200km present moves generated by thods applicable to a given w states of the world and no applicable methods that he appropriate state of the um2, the order in which the e total -ordering constraints. they will occur, the task me tree [ Figure 4] [Figure 5]. n Game Strategieswell established subfield of a mean for addressing AI AI technology.m for combining proble m-one of the most successful ars. CBR is based on the It means that new problems ncountered problems and, f use in the current situation lems where earlier cases are not understood well enough , diagnosis or classification ul areas of application, e.g., an illness from observed r not a certain treatment or olved cases [11]. rom HTNree AlgorithmInteractive and Adaptable Media 2973rd International Conference on Digital Interactive Media in Entertainment and ArtsCentral tasks that all CBR methods have to deal with are [12]: \"to identify the current problem situation, find a past case similar to the new one, use that case to suggest a solution to the current problem, evaluate the proposed solution, and update the system by learning from this experience. How this is done, what part of the process that is focused, what type of problems that drives the methods, etc. varies considerably, however\".  While the underlying ideas of CBR can be applied consistently across application domains, the specific implementation of the CBR methods in particular retrieval and similarity functions is highly customized to the application at hand. 4.2 CBR and Games Many different implementations of CBR exist in games. CBR technology is nicely suited for recognizing complex situations much easier and more elegant than traditional parameter comparison or function evaluation. There are especially evident cases in real time strategies where different attack and defense of global strategies are nicely define d by CBR datasets and later used in the running games. Also intelligent bots behavior is also another typical example. Depending on the number of enemy bots the layout of the terrain and position of human players the CBR system finds the closest CBR case and employs that strategy against the human players which in prior evaluation was proved to be highly efficient. 5. Game Trees with AI Planning  Tic-tac-toe In order to show the expressive power of AI Planning in defining strategies for games, and the use of these plans to build Game Trees I implemented an algorithm that builds Game Trees for the Tic-Tac-Toe game. The game tree of Tic-Tac-Toe shows 255,168 possible games of which 131,184 are won by X (the first player), 77904 are won by O and the rest 46,080 are draw [13]. All these games can be derived from building a complete Game Tree.  Even though it is possible to build a complete game tree of Tic-tac-toe it is definitely not an optimal solution. Many of the moves in this tree would be symmetrical and also there are a many moves that would be illogical or at least a bad strategy to even consider.  So what strategy should X (the first player) choose in order to win the game? There are few positions that lead to certain victory. These positions involve simultaneous attack on two positions so the other player could not defend, basically the only trick in Tic-Tac-Toe. Figure 6: Tic-tac-toe winning strategy positions Position 1 leads to victory if th e two of the three fields: top middle, bottom left corner and bottom right corner are free [Figure 6]. Position 2 lead to victory if tw o of the three fields: top right corner, bottom right corner and bottom middle are free [Figure ]. And in the third position if the two of center, middle top and middle left are available the position is a certain victory. There are many different arrangements of the players tokens that give equivalent positions as these three positions. By using planning we do not need to consider all possible layouts but just consider these three similar to what a human would consider.  The game starts from an empty table. The two relevant strategies that would lead to these positions are to take one corner or to take the center [Figure 7]. Figure 7: Tic-tac-toe Two starting moves The center position as we can see in the simulation results lead to a bigger number of victorious endings but it is also a straight forward strategy with obvious defense strategy. At this point we need to consider the moves of the opponent. If we take the left branch the opponent moves can be a center, a corner or a middle field. We also need to differentiate with a move to a corner adjacent with our like top left or bottom right or across the center to bottom right [Figure 8]. Figure 8: Tic-tac-toe opponent response to corner move In cases one and two, we have a clear path to executing strategy 3 so we need to capture the diagonally opposite field. And as for the third case the best wa y to go is to capture the center and go for strategy 1 or 2 depending of the opponents next move.  Figure 9: Tic-tac-toe move 2 after corner opening The first move leads to certain victory, O will have to go to the center and X will achieve strategy 3 [Figure 9]. The second move is a possible way to strategy 3 if O makes a mistake in the next loop, so X goes to the opposite corner. For the third case since O is playing a valid strategy the only move that leaves a possible mistake from O would be to take the center and wait for O to go to the middle and then achieve strategy 1 or 3 which will be a symmetric situation to the one that we will find if we branched with the center. Figure 10: Tic-tac-toe opponent response to center move If we go back to the second branch [Figure 10], a possible way for the second player to engage is corner or middle. The first 298 DIMEA 20083rd International Conference on Digital Interactive Media in Entertainment and Artsmove is a valid strategy for O and can be me ecorner move from X to try a mistake from O in the same as in the third case above from the pr eanother move would be go to the middle w hachieves strategy 1 or 2.  Figure 11: Tic-tac- toe Move 2 after cen tThe fist move will lead to win if O moves draw if it goes for the corners [Figure 11 ]. In thas to block the lower left corner which leavemiddle left or corner left which are strategy 1 an dTo sum the strategies for the planning, first corner strategy for the beginning. Then for the c ethe corners with the particularly the one oppoholds. If the center is empty for the second strat ewe go for the opposite corner. After this point wopponent or try to implement strategies 1, 2 o rvictory.  Plan 1 : Take center  Preconditions : Center empty Plan 2 : Take corner  Preconditions : All corners empty Plan 3 : Take corner after center Preconditions : We have center take corner oppo sopponent has Plan 4 : Take diagonal corner Preconditions : We have a corner, the opponent h a the corner opposite to the one we have is free. Plan 5 : Block Precondition : The opponent has tree tokens in a ragonal Plan 6 : Win Preconditions : We have two tokens in a row, colund the third place is free Plan 7 : Tie Preconditions : If all places are taken, its a tie. 5.1 Hierarchical Task Network Top level task is Play [Figure 12]. This is a can be derived into: Win, Block, Tie or Sea rSearch for plan is derived to both Plan 1 and Pl aPlan 4, which later leads to a call for the oppo nrecursive call to Play. Figure 12: Tic-tac-toe H Tet with a opposite the future exactly evious branch, and here X eventually ter openingto the middle or a the second case O es X to go for the d 2.we have center or enter we try to get osite to the one O egy we go  for it or we either block the r 3 which lead to site to the  one the as the ce nter androw, column or dimn or dia gonal aa complex task and rch for Plan. The an 2 or Plan 3 and nents move and a TNThis HTN when executed will r egame scenarios. By creating nodes fro mthem with branches wit h the move of ttree for the Tic-tac- toe game over wh ialgorithm. This set up wit h 7 plans with 3 t afor Tic-tac- toe which considers all po splayer w ith only 457 games, 281 of wand 0 where the second opponent wreduction over the 255, 168 possible gtree. These reductions can be very us ecomputing ca pabilities but also we p rthat planning can be very efficient if dtrees by applying reasoning very reasoning. Further improvements to the ga mthe opponent s moves are also planne dall the meaningless and symmetrical m6. Game AI in Monopoly 6.1Overview of the AI Im pThe AI agent is responsible for players in the game. The core principl ea Game Tree with all the sensible movemake from the current point of tim eminimax algorithm the agent selects twould bring the computer player m owith the highest probability. Building that would be big enough to consider is obstructed by the vastness of pos swith all the possible random landings nodes of the game tree exponentiall ytackle this problem the AI agents discussed te chnologies: Case Based R eThe technologies are employed First the agent searches the CBR data blargest similarity with the current stat eassociated with a playing strategy. T hthat the planner needs to build plans fconsecutive player moves that bring t hway only moves that are part of that st rbeing a small fraction of the overall p oedges of the game tree at each level de cAt each level of the game tree th eof a single player. After the strate gconsidered the response to those strat eby the opponent(s). The move of the probability distribution of the dice as player. A more general strategy need sopponents (human player) moves si nthe expertise of the opponent. This g emore plausible moves than the focuse dAfter covering all opponents tdeducting a feature move of the co mCBR selected plan strategy. After strategies and reaching a reasonable sinto account the memory limits a nprobabilities that the move is possibl ethe dice the building of the Game Tr ealgorithm searches the Game Tree favorable move for the AI player us iThe process is repeated each time the Aesult with plans for possible m each position and linking the player we create a game ich we can run the minimax arget strategies  creates a tree ssible moves for the second which X wins 176 are draw wins. This is a significant ames with a complete game eful for devices with limited rove a very important point designing meaningful game similar to human player me tree are also possible if d, in other words if we drop moves of the opponent. plementationthe moves of the artificial e of the AI agent is building es that all the players would e forward. Then using the the move that in the f uture ost favorable game position a Game Tree in this game sufficient number of moves sible moves in combination of the dice. The number of y grows at each level. To incorporates two already easoning and AI Planning. in the following manner. base to find the case with the e of the board. This case is he strategy consists of goal for, and the plans consist of he player to tha t goal. This rategy are considered, those ossible moves the number of creases immensely. e model considers the moves gies of the AI player are egies needs to be considered opponent(s) depends of the well as the strategy of the s to be implemented for the nce we cannot be aware of eneral strategy would bring d strategy of the AI player.  the agent comes back to mputer player by using the creating several loops of size of a Game Tree taking nd the rapidly decreasing e due to the distribution of ee stops. Then the minimax and decides on the most ing the minimax algorithm. AI player is up. Interactive and Adaptable Media 2993rd International Conference on Digital Interactive Media in Entertainment and ArtsBuying, auctioning and trading game moves are always accompanied by return of investment calculations in making the plans. These calculations represent adaptation of the more general planning associated with the cases in the CBR database. These adaptations are necessary due to the fact that the cases do not identically correspond to the situation on the table. In addition calculating the game position value of each node of the game tree is done by heuristic functions that incorporate economic calculations of net present value, cash, and strategic layout and so on. For example railroads in monopoly are known to be strategically effective because they bring constant income even though the income can be smaller than building on other properties.  6.2 Details on the CBR Implementation The implementation of the CBR is by using the JColibri2 platform.  JColibri2 is an object-oriented framework in Java for building CBR systems that is an evolution of previous work on knowledge intensive CBR [14].  For this implementation we need to look into three particular classes of the JColibri2 platform. The StandardCBRApplication, Connector, CBRQuery. For a JColibri2 implementation the StandardCBRApplication interface needs to be implemented.  The CBR cycle executed accepts an instance of CBRQuery. This class represents a CBR query to the CBR database. The description component (instance of CaseComponent) represents the description of the case that will be looked up in the database. All cases and case solutions are implementing the CaseComponent interf ace. The JColibri2 platform connects to the CBR database via a Connector class. Each connector implements all the necessary methods for accessing the database, retrieval of cases, storing and deletion of cases. This implementation uses a custom XML structure for holding the CBR cases. Since the game will not update the CBR database only read it, a XML solution satisfies the needs. The XML file to a certa in extent is similar to the XML representation of the board. We are interested in finding one CBRCase that is the most similar case to the situation in the game at the time of the search. This procedure is done in the cycle method of the CBRApplication. The JColibri2 CBR comparison is done by Nearest Neighbor (NN) search method.  JColibri2 offers implementations for NN search algorithms of simple attributes. These implementations are called local similarities. For complex attributes like in our case global customized similarity mechanisms need to be implemented. The MonopolyDescription class [Figure 13] is basically a serialization of the GameState. It holds all the information about the state of the board, the players, their amount of cash etc.  Figure 13: Class diagram of the Monopoly Case component models On the other hand the MonopolySolution class holds the three particular attributes that are needed for the planning, the planning Domain, State and TaskList. The game is implemented by using the Model-View-Controller software development pattern. The controller is responsible for implementing the game rules and handling all of the events in the game like roll of dice, input commands for trading, auctioning and etc from the players. The View layer is responsible for displaying the board and all of the input widgets on to the game screen, and the models are data structures representing the game state [Figure 14]. Figure 14: Class diagram of the Monopoly models 6.2.1 Complex Similarity representation in CBR The similarity measurement part of the Nearest Neighbor algorithm JColibri2 is implemented by implementing the LocalSimiralrityFunction and the GlobalSimiralityFunction interface. A local similarity function is applied to simple attributes by the NN algorithm, and a global similarity function is applied to compound attributes. In the case of our implementation the attributes of the MonopolyDescription are compound attributes describing the state of the board, number of players, amount of cash for every player and etc. Since MonopolyDescription is a custom CaseComponent a global similarity function needs to be implemented to accurately find the distance between different CBR cases. The similarity mechanism is inseparable core element of the CBR system. This mechanism represents how the CBR decides which strategy is best suited for the particular situation by 300 DIMEA 20083rd International Conference on Digital Interactive Media in Entertainment and Artscalculating the distance or similarity to other cases in the database.  For the monopoly implementation we need to consider several basic strategies. Monopoly is based on investing in properties and receiving revenues from those investments. One of the basic strategies of the game is to build a set of properties that will bring constant income larger than the one of the opponents. So in time the opponents will have to declare bankruptcy. But on the other hand over investment can lead to too stretched resources with low income that will eventually drove the player to bankruptcy. To decide on these two we need a clear separation into two groups of cases in the CBR database. The first group of cases will represent a situation on the board where the player has significant income per loop formed of one or more color group properties, maybe railroads, some buildings on them and so on. It is important to note that in this  case the player is better situated than his opponents so he only needs to survive long enough to win the game. In the other group of cases either the opponent is not well positioned on the board or its opponents are better situated. In this case further investments are necessary to improve the situation so the player can have a chance of winning in the long run.  These metrics can be owning color groups, valuing groups of railroads, evaluating the other opponents as well, and considering the amount of cash. As it is obvious in monopoly the number of streets is not as nearly as important as the combination of streets the player owns. It is also important to note that one CBR case does not hold only a single strategy in place, but its solution can have multiple different strategic goals. For example one CBR case might simultaneously say buy this land to form a color group but also trade some other unimportant property to increase cash amount.  The cases do not represent all possible combinations of board positions. They are only representation of typical game scenarios. The CBR Case solutions do not give exact instructions in general but rather strategic goals. For example one CBR Solution might say trade the streets that you only have one of each for the ones that you have two of that color already. Then the planner based on the situation on the board needs to decompose this high level task to a low level operations. Like offer \"Mediterranean Avenue\" for \"Reading Railroad\" and offer $50. The exact amounts and actual streets are left to the planer to evaluate.  The monopoly CBR database is currently in development on a monopoly clone game called Sp aceopoly. The cases are architected based on human player experience and knowledge. There is a plan of making a number of slightly different strategies that differ on the style of playing and then running simulation tests that would determine the particular validity of each database as well as validity of certain segments of the strategy or even particular cases in the database.  The actual execution of the strategies will not differ from strategy to strategy since the plan  execution is more related to the structure and rules of the game than to the actual playing strategy. 6.3 Details on the Planning Implementation For the purpose of planning this implementation uses a modification of the JSHOP2 planner. The Java Simple Hierarchical Ordered Planner 2 is a domain independent HTN planning system [15].  JSHOP2 uses ordered task decomposition  in reducing the HTN to list of primitive tasks which form the plans. An ordered task decomposition planner is an HTN planner that plans for tasks in the same order that they will be executed. This reduces the complexity of reasoning by removing a great deal of uncertainty about the world, which makes it easy to incorporate substantial expressive power into the planning algorithm. In addition to the usual HTN methods and operators, the planners can make use of axioms, can do mixed symbolic/numeric conditions, and can do external function calls.  In order for the JSHOP2 planer to generate plans it needs tree crucial components: Domain, State and Tasks. The Domain defines all the functionalities that the particular domain offers. These are simple and complex tasks. The complex tasks also called methods create the hierarchy with the fact that they can be evaluated by simple tasks of other complex tasks. This is how a hierarchical structure of tasks is formed. The problem reduction is done by reducing the high level complex tasks to simpler until all the tasks are primitive. The list of primitive tasks forms the plan. The State represents the state of the system. It is a simple database of facts that represent the state of the system. The State is necessary to determine the way the problems or tasks are reduced to their primitive level. The reduction is done by satisfying different prerequisites set in the methods; these prerequisites are defined in the state. The Tasks are high level tasks or methods defined in the Domain. The planner based on the State and the goals selects one or more high level tasks that need to be reduced to plans [Figure  15]. Figure 15: Diagram of a Planner The plans then generate the game moves. The number of moves generated by the plans is just a fraction of the possible moves at that point. This reduces the game tree providing the opportunity to generate smaller and deeper game trees and making more efficient decisions in general.  7. Conclusion Even though the results from the CBR database are not complete at this time partial strategies are implemented as cases and recognized during game play by the CBR system. These smaller local strategies coupled with more global higher level strategies that are particularly important at the beginning of the game would form a complete CBR database and represent a knowledge engineered style of playing of the AI player.  The AI Planning approach is a proven method by the tic-tac-toe experiment and is suitable for implementing the strategies associated with the CBR cases. This approach in general benefits from both technologies, CBR as well as AI Planning and comprises an elegant solution. Even though AI Planning can be enough as a single technology for some simpler problems like tic-tac-toe the complexity of Monopoly would mean that the Planner would have to incorporate Core Planner TasksPlan StateInteractive and Adaptable Media 3013rd International Conference on Digital Interactive Media in Entertainment and Artslarge and complex domain and a very big state model. The CBR application helps reduce this complexity by focusing the planning on smaller domain of the game. Basically the CBR reduces the overall goal of the play (wining the game) to smaller more concrete goals suitable to the particular state of the game, thus reducing the need for global planning strategies and complex planning domain.  Furthermore this symbiosis of technologies gives way for more precise and finely tuned strategies which can be difficult to include into global plan for the whole game. One simple example for the Monopoly game would be this: Sometimes its better to stay in jail because rolling double increases the probability of landing on some field (two, four, six, eight, ten or twelve steps from the jail) that can be of gr eat importance to the rest of the game. These and similar small local strategies can be easily recognized by similar cases in the CBR database.  In other words the system is flexible enough so that new strategies can be incorporated easily missing strategies can be also recognized by the distance metrics as well as wrong assumptions in the strategies can be easily recognized. One other important property of the system is that is highly configurable. The game its self can be diversely different depending on the configuration of the board. Even though the platform is restricted to Monopoly type of games, changing the layout and values of the fields effectively brings completely different properties of the game. In addition the CBR database represents the entire experience of the AI Player. It can be filled with rich set of strategies or even configured with different flavors of difficulties of play, this of course coupled with the domain of the planner which can differ from a case to a case as well.  8. Future Work Further exploration of this technology would go towards complete implementation of an AI aware agent for monopoly. Initial results from the local case s with more specific strategies show CBR as a capable tool for representing expertise in playing the game. Completing the more general strategies and c oupling them with the planning domain will give precise results on the benefits from this architecture. There is also need for exploring the planning of strategies of opponents. This task is to some extent different because we cannot always expect the opponent to select the best move we think. In the Tic-tac-toe example all possible moves of the opponent were taken into consideration, if we used the same planner for the opponent only tie games would result from the game tree. In other words mistakes of the players also need to be considered.  The CBR Platform brings other functionalities well worth of exploring as well. The revision stage of the JColibri2 platform is basically capable of fine tuning strategies or even developing new strategies for the games. A well written underlying AI planning model with a capable feedback of the game tree evaluation back to the CBR revision capability can be an interesting concept in automatic experience acquisition for the AI model. There are also many other fields were combined CBR and planning approach can be incorporated into a problem solution. This combination is analogous in a big extent to a human way of reasoning. People in addition to lo gic of reasoning in situations with lack of information rely to planning strategies and prior experience, exactly the intuition behind CBR  AI Planning architecture.  9. ACKNOWLEDGMENTS We would like to thank Prof. Sofia Tsekeridou for her involvement in the valuable discussions we had on the topic of CBR. 10. REFERENCES [1] Minimax. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Minimax . [2] Von Neumann, J : Zur theorie der gesellschaftsspiele  Math. Annalen. 100 (1928) 295-320 [3] Automated Planning. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Automated_planning . [4] Sanchez-Ruiz, Antonio, et al. Game AI for a Turn-based Strategy Game with Plan Adaptation and Ontology-based retrieval .[5] K. Erol, J. Hendler, and D. Nau  (1994). Semantics for hierarchical task-network planning . Technical Report TR-94-31, UMIACS. [6] Smith, S. J. J. and Dana S. Nau, T. A. Throp.  A Planning approach decrarer play in contract bridge. Computational Intelligence. 1996, Vol. 12, 1. [7] One Jump Ahead: Challenging Human Supremacy in Checkers. J.Schaeffer.  s.l. : Springer-Verlag, 1997. [8] IBM.  How Deep Blue works. [Online] 1997. [Cited: April 23, 2008.] http://www.research.ibm.com/d eepblue/meet/html/d.3.2.html[9] Ghallab, Malik, Nau, Dana and Traverso, Paolo.Automated Planning theory and practice. s.l. : Morgan Kaufmann Publishers, May 2004. ISBN 1-55860-856-7. [10] Case Based Reasoning. Experiences, Lessons and Future. Leake, David.  s.l. : AAAI Press. MIT Press., 1997. [11] Applying case-based reasoning: techniques for enterprise systems. Watson, I.  San Francisco, CA, USA : Morgan Kaufmann Publishers Inc., 1998. [12] Plaza, A. Aamodt and E.  Case-based reasoning: Foundational issues, methodological. AI Communications. 1994, 7(i). [13] Tic-tac-toe. Wikipedia. [Online] [Cited: April 23, 2008.] http://en.wikipedia.org/wiki/Tic-tac-toe. [14] Daz-Agudo, B. and Gonzlez-Calero, P. A.  An architecture for knowledge intensive CBR systems. Advances in Case-Based Reasoning  (EWCBR00). New York : Springer-Verlag, Berlin Heidelberg, 2000. [15] Ilghami, Okhtay and Nau, Dana S. A General Approach to Synthesize Problem-Specific Planners. 2003. 302 DIMEA 20083rd International Conference on Digital Interactive Media in Entertainment and Arts','PDF_1706922830.pdf','2008-09-10 00:00:00.000000'),(99,'How to Teach Software Modeling','To enhance motivation of students to study software engineering, some way of finding balance between the scientific aspect and the practical aspect of software engineering is required. In this paper, we claim that teaching multiple software modeling techniques from a unified viewpoint is a good way of obtaining the balance and attracting the students\' interest as well.','software modeling, software engineering education, UML','How to Teach Software ModelingTetsuo TamaiGraduate School of Arts and SciencesThe University of Tokyo3-8-1 Komaba, Meguro-kuTokyo 153-8902, Japantamai@acm.orgABSTRACTTo enhance motivation of students to study software engineering,some way of nding balance between the scientic aspect and thepractical aspect of software engineering is required. In this paper,we claim that teaching multiple software modeling techniques froma unied viewpoint is a good way of obtaining the balance andattracting the students interest as well.Categories and Subject DescriptorsK.3.2 [ Computers and Education ]: Computer and InformationScience Education computer science education ; D.2.1 [ SoftwareEngineering ]: Requirements/Specication modelingGeneral TermsDesignKeywordssoftware modeling, software engineering education, UML1. INTRODUCTIONSoftware engineering education at universities faces a commonproblem; that is regular students do not usually have experience ofdeveloping software for practical use and thus are not motivated forsoftware engineering aiming at high quality software productionby a project team or a persistent organization. Software projectsconducted by students simulating real scale software developmentmay help enhance students motivation, although it requires a lot ofefforts to prepare such projects and manage them.Another way of solving this problem is to teach those who al-ready have real experience in industry. In our case, there are cur-rently ve Ph. D. students under the authors supervision who areworking at companies as well as doing research in our lab. Asa by-product, interactions between the part-time students and theother regular students stimulate each other, particularly enlighten-ing the regular students to practical software issues. However, toomuch emphasis on practicality may bring negligence to science andCopyright is held by the author/owner.ICSE05, May 1521, 2005, St. Louis, Missouri, USA.ACM 1-58113-963-2/05/0005.technology and may generate anti-intellectualism. A good balancebetween the scientic aspect and the practical aspect of softwareengineering should always be pursued.In our view, teaching various software modeling techniques is agood way to achieve balanced software engineering education. Itis needless to say that model is a key concept and modeling is anessential skill in software engineering. There are a variety of mod-eling techniques; some are intuitive and quite accessible to novices,while some are highly sophisticated and attract theory oriented stu-dents and researchers.In this paper, we would like to show that it is effective to teachmultiple modeling techniques from a unied viewpoint. It is basedon our experience of teaching software engineering courses at sev-eral universities in Japan. Recently, the author published a textbookon software engineering, specically focused on software model-ing (unfortunately, it is written in Japanese)[1]. The book coversthe whole area of software engineering, including design, testingand evolution but the modeling part has a role of attracting inter-ests of intelligent students, who may not have much experience indeveloping real scale software systems. It also gives a consistentviewpoint penetrating through various techniques employed in dif-ferent stages of software engineering.2. MODELING TECHNIQUESIn software engineering, models are used for various purposes,e.g. life cycle model, process model, project model, product model,quality model, domain model, requirements model, design model,object model, data model, etc. In the following, we basically focuson requirements and design models but most of the discussions willhold for other kinds of models.Teaching modeling is almost equal to teaching abstraction. Mod-els are constructed through capturing the crucial properties andstructure of the target, abstracting away irrelevant details. Thus,learning how to model is a good training for mastering abstraction.2.1 Graph Representation of ModelsMany software models are represented with diagrams. Wide ac-ceptance of UML symbolizes the trend that diagrams are often pre-ferred to textual languages. Among many types of diagrams, graphstructured diagrams are by far the most widely used. The reasonsmay be as follows.1. A most fundamental way for human mind to understand theworld is by regarding it as consisting of a set of conceptualunits and a set of relations between them. Conceptual unitscan be naturally illustrated with boxes or circles or whateverclosed gures and relations can be illustrated with lines or ar-rows connecting such gures, corresponding to vertices andedges of graphs, respectively.609 2. It is easy to draw graph structured diagrams by hand or withdrawing tools.3. Concepts and algorithms of the graph theory are availableand often useful in analyzing models represented by graphs.A typical example is reasoning on transitive relations by trac-ing along paths of graphs. Also, the concept of subgraph ishighly useful in decomposing higher-level models or cluster-ing lower-level models.Accordingly, a number of models share the same structure ofgraphs. Table 1 shows graph structures of some typical models.Table 1: Graph structures of typical modelsmodel vertex edgeData ow process data owER entity relationshipState transition state transitionJSD process data stream connectionstate vector connectionActivity activity control owPetri net place, transition re and token ow2.2 Commonality and Difference betweenModelsIt is pedagogical to let students notice the common structureshared by a number of models. However, the apparent resemblanceoften causes confusion. Such confusion can be observed not onlyin software modeling graphs but in many diagrams found in dailynewspapers, magazines, reports, proposals and other documents. Itis often the case that one vertex denotes a type of things and an-other denotes quite a different type on the same diagram or onetype of edges co-exist with edges with different meaning. Thus,it is important to make students consciously aware the differencesbetween different models. We often experience that when we letstudents draw data ow diagrams who appear to have understoodthe data ow model perfectly, the diagrams turn out to be some-thing like control ow graphs.To show the difference, it is instructive to categorize models rep-resented by graphs. Basically, there are two categories.1. Static models:An edge connecting vertex A and vertex B represents a rela-tion between A and B. When the edge is undirected, it meansA and B are in some relation and when directed, it meansA has a relation with B. Typical examples include entityrelationship model, class diagram and semantic network.2. Dynamic models:An edge from vertex A to B denotes a move from A to B.The edge in this case is always directed. There are two sub-categories:(a) The case where a view of control moves from A to B.Examples are control ow model and state transitionmodel.(b) The case where data or objects ow from A to B. Exam-ples are data ow model, work ow model, and trans-portation ow model.Static models and dynamic models may not be easily confusedbut confusion between different dynamic models are often observed,e.g. data ow and control ow or state transition and activity tran-sition. Since graphs are intuitively understandable, their semanticsare apt to be understood ambiguously or misunderstood.3. UMLUML diagrams can also be viewed in terms of graph structures.Table 2 shows graph structures of ve UML diagrams.Table 2: Graph structures of UML diagramsdiagram vertex edgeclass diagram class generalization,composition,associationstate machine state transitionactivity diagram activity control owcollaboration diagram object message owsequence diagram message message owanchor pointIt is usually not desirable to teach UML per se. UML is a col-lection of miscellaneous diagrams and its specication is continu-ously changing. For the pedagogical purpose, UML had better beregarded as a catalogue of analysis and design know-how collectedaround diagrammatic representations. Diagrams should be selectedaccording to the policy of how to teach modeling methods.Each UML diagram contains overly rich constructs, which some-times blur the essential property of the model. For example, theactivity diagram is essentially a control ow diagram but it also in-cludes a notation for data ow description. From the stance of em-phasizing differences between various models, it is not appropriateto include such ad hoc constructs. By the same token, the collab-oration diagram (, renamed to communication diagram in UML2) is explained to have the equivalent semantics as the sequencediagram. But if that is the case, signicance of the collaborationdiagram is considerably limited. The author prefers to regard it asshowing collaboration relations between objects, integrating a setof different sequence diagrams.4. CONCLUSIONSoftware modeling is important by itself but teaching modelingin the software engineering course has at least two additional mean-ings. One is to give a birds-eye view to the whole software engi-neering through the standpoint of modeling technology. The otheris to attract interest of good students who may not have much expe-rience in developing a real-scale software but possess intelligenceand will to attack complexity of modern software construction.5. REFERENCES[1] T. Tamai. Foundations of Software Engineering . IwanamiShoten, Tokyo, Japan, 2004. in Japanese.610 ','PDF_1706923511.pdf','2005-05-15 00:00:00.000000'),(100,'Numerical computing in engineering mathematics','The rapid advances in technology over the last decade have signiﬁcantly altered the nature of engineering knowledge and skills required in the modern industries. In response to the changing professional requirements, engineering institutions have updated their curriculum and pedagogical practices. However, most of the changes in the curriculum have been focused on the core engineering courses without much consideration for the auxiliary courses in mathematics and sciences. ... The goal of this paper is to propose a modernized engineering mathematics curriculum in line with the broader efforts to update engineering education to adapt to Industry 4.0. The key feature of the new curriculum is the introduction numerical computing in the existing mathematics courses. ... By studying numerical computing in mathematics courses, students will acquire the necessary theoretical and practical skills to apply in their downstream, specialized engineering courses.','engineering mathematics, numerical computing, education, Industry 4.0','arXiv:2207.04698v1  [math.HO]  11 Jul 2022Numerical computing in engineering mathematicsFiruz KamalovDepartment of Electrical EngineeringCanadian University DubaiDubai, UAEruz@cud.ac.aeHo-Hon LeungDepartment of Mathematical SciencesUnited Arab Emirates UniversityAl Ain, UAEhohon.leung@uaeu.ac.aeAbstract The rapid advances in technology over the lastdecade have signicantly altered the nature of engineering knowl-edge and skills required in the modern industries. In respon se tothe changing professional requirements, engineering inst itutionshave updated their curriculum and pedagogical practices. H ow-ever, most of the changes in the curriculum have been focused onthe core engineering courses without much consideration fo r theauxiliary courses in mathematics and sciences. In this pape r, weaim to propose a new, augmented mathematics curriculum aime dat meeting the requirements of the modern, technology-base dengineering workplace. The proposed updates require minim alresources and can be seamlessly integrated into the existin gcurriculum.Index Terms engineering mathematics; numerical computing;education; Industry 4.0I. I NTRODUCTIONThe 4th Industrial Revolution has had a dramatic impacton the engineering profession. The modern technologies suc has articial intelligence, the internet of things, and adva ncedrobotics have altered engineering systems and processes. T o-days engineers are expected to be able to leverage theseresources to produce their products. To meet the new profes-sional requirements, engineering educational institutio ns haverevised their curricula. The changes in the curricula inclu deboth updating the existing programs as well as introduc-ing completely new programs. Given the rapid technologicalprogress, universities and colleges around the world are co n-tinuously adapting to the ever-changing environment. Whil e asignicant progress in modernizing the engineering curric ulumhas been achieved, there still remains room for improvement .Catalyzed by the exponential increase in computationalpower and interconnectedness, the modern industrial revol u-tion has reshaped the skills and competencies required of th eengineers. The changes in engineering curricula in respons e toIndustry 4.0 have been threefold: i) modernizing the existi ngprograms, ii) introduction of new programs, and iii) revisi ngthe pedagogical approach. Modernizing the existing progra msinvolves introduction of new courses in the study plan relat edto emerging technologies. In addition, existing courses ca n beupdated with new content. Fresh new programs in emerging 2022 IEEE. Personal use of this material is permitted. Perm ission fromIEEE must be obtained for all other uses, in any current or fut ure media,including reprinting/republishing this material for adve rtising or promotionalpurposes, creating new collective works, for resale or redi stribution to serversor lists, or reuse of any copyrighted component of this work i n other workstechnologies are also introduced by universities and colle ges.Many institutions now offer degrees in articial intellige nceand mechatronics which were not there 20 years ago. Finally,universities have revised their approaches to course deliv ery.Student-centered learning, project-based learning, and a ppliedlearning have become popular in the new engineering educa-tional paradigm.While signicant effort has been made to revise the coreengineering courses, the auxiliary courses in mathematics andsciences received little consideration. The mathematics a ndsciences courses play a key role in the engineering curricul um.Given their importance, the curriculum updates must also beextended to the auxiliary courses. By implementing a com-prehensive update of the engineering curriculum that inclu desboth the core and auxiliary courses, a more effective outcom ecan be achieved.The goal of this paper is to propose a modernized engineer-ing mathematics curriculum in line with the broader efforts toupdate engineering education to adapt to Industry 4.0. The k eyfeature of the new curriculum is the introduction numericalcomputing in the existing mathematics courses. The latestindustrial revolution has been driven largely by the dramat icincrease in computational power. Therefore, todays engin eersmust be well-equipped to leverage the computing power intheir work.Since mathematics courses are usually taken at the begin-ning of the study plan, it offers a natural avenue for introdu cingnumerical computing to students. Furthermore, many proble msin mathematics can be solved numerically making it naturalto integrate numerical computing in mathematics courses.By studying numerical computing in mathematics courses,students will acquire the necessary theoretical and practi calskills to apply in their downstream, specialized engineeri ngcourses.This paper is structured as follows. Section 2 provides anoverview of the existing efforts to update the engineeringcurriculum in response to Industry 4.0. Section 3 discussesthe current approaches to integrate scientic computing inmathematics courses. In Section 4, we present our proposalfor modernizing the mathematics curriculum to integrate nu -merical computing. Section 5 concludes the paper with nalremarks.II. E NGINEERING EDUCATION AND INDUSTRY 4.0Engineering departments in colleges and universities havemade signicant changes in their curricula in response tothe new environment created by the recent, rapid advancesin technology. In particular, the existing programs have be enupdated to include courses that target emerging technologi es.Completely new programs related to AI and mechatronicshave also been adopted by universities. Innovations in theeld of engineering education continue to take place with ne wdevelopments on the horizon.There exist several studies investigating the modern en-gineering curricula and evaluating their effectiveness. I t isargued in [6] that engineering educators must prepare theirstudents to face three key challenges: sustainability, the 4thIndustrial Revolution, and employability. The authors nd thatcolleges and universities are responding to these challeng es byemphasizing student-centered learning, integration of th eoryand practice, digital and online learning, and the denitio n ofprofessional competencies. In particular, response to the needsof Industry 4.0 require interdisciplinary collaboration a crossseveral programs and disciplines. Interaction and integra tionof technologies plays a key role in this process [10], [12]. I n-terdisciplinary engineering education requires sound ped agogyand teaming experiences to encourage student in collaborat iveand interdisciplinary practice [23].Digital and online learning have become an important partof modern education including in the eld of engineering.Information technologies play a vital role in delivering di gitallearning to students. Colleges and universities have madesignicant investments to improve their information and co m-munication technology (ICT) capacities [7].In response to the needs of Industry 4.0, some univer-sities have adopted the framework of Education 4.0 [15],[19]. The new education framework consists of four maincomponents: i) competencies, ii) learning methods, iii) IC T,and iv) infrastructure. Students competencies are based ontechnological knowledge and skills for successful workpla ceperformance, while the learning methods are based on proble msolving and challenge-based learning. In particular, acti ve andproject-based learning plays an important role in Educatio n4.0 [4], [8]. Other innovative approaches to learning such a svirtual-reality based engineering education can help impr ovethe learning process related to Industry 4.0 [20].In addition to technological progress, socio-cultural shi ftsmust be taken into account in revising engineering curricul um.The new generation of students has its unique worldviewwhich needs to be considered by the educators. In particular ,the new generation is signicantly affected by mobile devic esand digital media. Educational content must be tailored tothe new student preferences to achieve effective learningoutcomes [16]. Innovative approaches such gamication mayhelp improve the learning process [13], [17].Many universities have also introduced nontechnical updat esto their engineering curriculum. The most signicant nonte ch-nical update has been the introduction of entrepreneurshipcourses and experiences for students. A lot of attention hasrecently been given to equipping students with entrepreneu rialskills. Students learn about entrepreneurship in their cou rsesas well as through university incubators.III. U NIVERSITY MATHEMATICS CURRICULUMThe mathematics curriculum changed very little in thecurrent century. It remains a largely analytic domain, wher e so-lutions are mainly obtained manually. The current mathemat icscurriculum emphasizes theory over practical approaches. F orinstance, when nding the extreme values of a function,derivative-based approach is preferred over the gradient d e-cent. There are two key reasons for why analytical approache sare favored over numerical methods. First, analytical solu tionsare reliable and elegant. An analytical solution is guarant eedto be exact. Second, mathematics courses are usually taughtby pure mathematicians who have an inherent preferencefor analytical solutions. Pure mathematics which is based o ntheorem proving is not amenable to numerical methods.Despite the popularity of analytical approaches to problemsolving in mathematics, there has been a growing push to inte -grate computer algebra systems as part of the learning proce ss.Computer algebra systems such as Matlab and Mathematicaare now routinely used in many mathematics courses. Thestudy by Cretchley et al. [5] found that engineering student swere positive about the use of technology as a learning toolin mathematics courses. The increased use of technology inclass helped improve student focus and interest in lectures .Student evaluations also indicated that they had a greater l evelof enjoyment towards the lectures due to the use of technolog y.It is noteworthy that students chose not to rely too heavily o ntechnology during the examinations despite the freedom to d oso. The students found it extremely important to be competen twith analytical mathematical skills as opposed to purely co m-putational skills. Some revealed that they learn the subjec tsequally well without the help of scientic packages, althou ghthe perception towards the use of computer is in general high lypositive. Almost all students responded positively to Matl abas an effective tool for computation and graphing. Manyused Matlab for non-examination purposes. For example, the yutilized it to check their handwritten mathematical steps i nassignments and practice problems; and others used it forexploration beyond the standard syllabus and curriculum.The inuence of computer technology on students aca-demic performance and learning experience has been inves-tigated by several authors. Abdul Majid et al. [1], [2] usedMatlab as an aid to teach calculus to engineering students.The software package was used for various course learningoutcomes such as graphical display of mathematical functio ns,exploration, identifying and predicting structural patte rns inevaluating a series of complex indenite integrals, and num eri-cal approximations in applied mathematics. The study showe da positive impact on students academic performance in thenal examinations. The study concluded that the integratio nof scientic packages into engineering mathematics course scould be effective under certain conditions. Similarly, ot herstudies [18], [21] also found a positive impact from the useof scientic software packages on students motivation inlearning mathematics.In a separate study by Brake [3], the authors investigated th euse of Matlab in engineering mathematics courses to increas estudent condence level and mathematical abilities. Matla bwas used to solve concrete engineering problems which requi rea deep understanding of underlying mathematical principle s.The study found generally positive student response to theuse of software in their mathematics courses. However, theresults of the study must be considered carefully given thesmall sample size of the subjects.Although the majority of the studies were based on theuse of Matlab, several other studies considered alternativ emathematics software packages. The study by Kilicman et al.[11] focused on the use of Maple to help students understandboth the theoretical and computational aspects of linear al gebrafor engineering students. In particular, it was shown that t heuse of Maple facilitates the understanding of computationa l as-pects of eigenvalues and eigenvectors. It allows students m oretime to focus on the theoretical aspects and the underlyingmathematical principles.In a recent study by Mezhennaya and Pugachev [14], theauthors compared engineering students perceptions regar dingseveral mathematical software: Matlab, Mathematica and Ex -cel. The study found that all the scientic packages conside redcan be used in education, under the condition that the polici esfor software usage are carefully implemented. The studyfound that many students lack hands-on experience on howto use the software. The students particularly struggled wi thMatlab and Mathematica nding them non user friendly. Thestudy concluded that additional classes are required to pre parestudents to use software in their courses.IV. N UMERICAL COMPUTING IN MATHEMATICSCURRICULUMMathematics lies at the foundation of science and engineer-ing. The importance of mathematics courses in engineeringeducation cannot be underestimated. These courses equip st u-dents with the fundamental skills and knowledge to study themore specialized engineering courses. Thus, student succe ss inengineering studies depends directly on the mathematics an dsciences courses. Given the signicance of the mathematicscourses in the engineering curriculum, it is paramount toensure their currency with respect to the Industry 4.0.The technological advances over the last decade havecreated demand for more computationally procient experts .To meet this demand, numerical computing must become acore part of engineering studies. Mathematics courses offe ra natural and convenient avenue for introducing numericalcomputing to engineering students. There are two main fac-tors that make mathematics courses particularly amenableto numerical computing. First, in many cases mathematicalproblems have numerical solutions. For instance, nding th eroot of a polynomial or the minimum value of a functioncan be done numerically. Therefore, it is both logical andappropriate to apply numerical computing to mathematicalproblems. Second, mathematics courses are usually takenat the beginning of the study plan. Thus, students becomeacquainted with numerical computing at an early stage. Thecomputing and programming skills acquired in this mannerwill have a positive effect in the more advanced, downstreamengineering courses.The key idea for the proposed curriculum update is theaddition of computing tutorials (labs) to mathematics cour ses.In particular, we propose adding weekly computing tutorial s(labs) related to the main lecture material. For instance, i n theweek in which students cover nding the extreme values of afunction, there will be a computing tutorial where studentslearn and implement the gradient descent algorithm. Thesuggested length of each tutorial is 1 hour. It is enoughtime to implement most of the numerical algorithms at theundergraduate level. At the same time, 1 extra hour per weekwill not overburden the students.The exact details of numerical computing content is leftfor individual universities and instructors. Depending on thesyllabus and course learning outcomes, the numerical com-puting labs will be different for each university and instru ctor.Nevertheless, the general ideas will be broadly similar acr ossdifferent curricula. To illustrate the proposed numerical com-puting content, we will focus on the three main concept incalculus: limits, derivatives, and integrals.A. LimitsLimit is a fundamental concept in calculus. Students areusually taught to calculate limits using analytical approa ches.Although analytical approaches work well, there is no singl euniversal rule for calculating limits. On the other hand, in mostcases, limits can be calculated numerically using essentia llythe same approach. To illustrate, suppose we want to calcula telimxa+f(x). Then we can loop for k= 0 tonand calculatef(a+10k). Askincreases, a+10kapproaches a, sof(a+10k)will, in most cases, approach the limit value. We candeduce the limit by observing the values of f(a+ 10k)ordetermine that the limit does not exist if there is no pattern ofconvergence. The value of ncan be chosen manually or usinga stopping criterion. For instance, the algorithm may conti nueto iterate until the difference between consecutive values off(a+ 10k)is below a certain threshold. The value of thelimit can also be deduced automatically based on the valuesoff(a+10k)using various heuristics.Another common limit problem is limxf(x). In thiscase, we can loop for k= 0 tonand calculate f(10k). Askincreases, 10kapproaches , sof(10k)will, in most cases,approach the limit value. Then the limit can be determinedbased on the values of f(10k). Various extensions and cus-tomizations of this basic approach can be made. For instance ,to avoid issues with periodic functions f(10k+k), wherekare randomly generated, can be used. Other values than 10kcan also be used as long as the sequence approaches innity.A degree of automization can be introduced using differentheuristics.B. DerivativeDerivative is arguably the most important concept in cal-culus. There exist several rules such as the power rule, theproduct rule, the chain rule, and others to nd the derivativ eof a function by hand. However, manual differentiation maybe cumbersome when dealing with complex function. On theother hand, calculating the derivative at a point numerical ly isrelatively straightforward. To illustrate, suppose that w e wantto calculate f(a). Recall thatf(a) = limxaf(a+h)f(a)h. (1)Therefore, to calculate f(a)numerically we use the sameapproach as with the limits. In particular, we can loop for k=0tonand calculatef(a+10k)f(a)10k . Then the limit, and byextension the derivative, can be deduced (approximated) ba sedon the calculated values. The accuracy of the approximationdepends in large part on the value of n.One of the most important applications of the derivative isnding the extreme values of a function. Traditionally, thi s isdone by rst nding the critical points of the function andthen applying the second derivative test. However, nding t hecritical points is not always possible, so numerical approa chescan be used in such cases. The most popular numericalapproach for nding the extreme values is based on thegradient descent (ascent) algorithm. In gradient descent, theoptimal value of xis iteratively updated based on the gradient.In particular, for k= 0 ton, the updated optimal value of xis given byxk+1=xkf(xk), (2)wheref(x)is the gradient and is the step size. In thecase of a single-variable function, the gradient equals sim plyto the derivative f(x) =f(x). The step size can beeither xed or dynamic. While a large value of acceleratesthe convergence at the beginning, it may hurt the convergenc ein the region near the optimal value.There exist several extensions of the basic gradient descen talgorithm. One such extension is gradient descent with mo-mentum which uses the second derivative to anticipate thelocation of the next optimal point and thus accelerates theconvergence.C. IntegralsIntegration is an important concept in engineering mathe-matics. Although there exist a number of rules for nding theintegral, it is signicantly more challenging than differe ntia-tion. Moreover, in many cases, the indenite integral does n oteven exist. Therefore, numerical approaches are particula rlyuseful for integration.To illustrate the application of numerical integration, su p-pose that we want to calculate/integraltextbaf(x)dx. There exist severalnumerical methods for calculating the integral. One simplemethod is based on the Riemann sums. The interval [a,b]isdivided into nequal subintervals with endpoints x0,x1,...,xn.Let=xk+1xkbe the length of each subinterval. Then theright Riemann sum is dened as /summationtextnk=1f(xk). The Riemannsum provides an approximation of the integral. Indeed,/integraldisplaybaf(x)dx= limnn/summationdisplayk=1f(xk). (3)The Riemann sums can be quickly calculated on a computerproviding a simple, yet effective approach to calculatingintegrals numerically. Other popular integral approximat ionmethods include the trapezoid rule and the Simpsons rule.D. Additional considerationsThe above discussion about numerical methods for cal-culating limits, derivatives, and integrals is easily exte ndedto multivariate calculus. For instance, to nd the partialderivative fx(a,b), we can loop for k= 0 tonand calculatef(a+10k,b)f(a,b)10k . Many problems related to sequences andseries can similarly be solved using numerical techniques. Inparticular, the convergence of a series can be deduced from i tspartial sums. By calculating the partial sums on the compute rand observing the results, we can intuit the nature of the ser ies.Vectorization is an important aspect of numerical com-puting. Since the modern computer chips are optimized formatrix multiplication, it is more efcient to employ vectoroperations. In particular, some algorithms based on for-lo opscan be converted into vector operations resulting in higherefciency and speed. For instance, the Riemann sum can becalculated with a single vector operation:n/summationdisplayk=1f(xk) =S/parenleftbigf(x)/parenrightbig, (4)wherex= [x1,...,xn]is the vector of endpoints, f(x)isa vectorized function operation, and Sis the vector func-tion which returns the sum of all the coordinates. Similarly ,limit calculations can be vectorized and made more efcient .Vectorization is also useful in multi-variate calculus, wh ereoperations can be performed on a vector of variables.The choice of the programming language for numericalcomputing requires careful consideration. There are sever alsuitable candidates for this purpose including Python, Jav a,C++, Matlab, and others. Based on our experience withdifferent programming languages, we recommend the use ofPython. Python is currently the most popular programminglanguage on the planet. It has a simple and intuitive syntaxmaking it easy to learn and apply. Python has libraries tot any purpose including an extensive collection of librari esrelated to numerical computing. The basic Python librariesrelated to computing are NumPy, SciPy, and SymPy. Moreadvanced packages such as OR-Tools are also available foroptimization tasks. Since Python is a universal programmin glanguage, it can be used for almost any task. Thus, studentswho learn Python in their mathematics courses can employit in their other courses. In addition, numerical computingimplemented in Python can be connected to other application s.V. C ONCLUSIONAlthough the classical approach to teaching mathematicsis still relevant for certain student cohorts, it is outdate d forengineering students. Modern engineering is increasingly re-liant on computing [9], [22]. Therefore, universities must equipthe student with appropriate computing skills. In particul ar,mathematics courses must be revised to include numericalcomputing content.Given the efciency of computer-based calculations, numer -ical computing provides a convenient approach to problemsolving in engineering mathematics. It can be integrated in tothe existing curriculum with little hassle and cost. In this paper,we proposed a framework for integrating numerical computin ginto the existing mathematics curriculum. We demonstratedhow numerical approaches can be used some of the mostcommon problems encountered in calculus. The proposedframework can be customized by individual universities to  ttheir special needs.REFERENCES[1] Abdul Majid, M., Huneiti, Z., Balachandran, W., & Al-Naa fa, M. A.(2012) A study of the effects of using MATLAB as a pedagogical toolfor engineering mathematics students. 15th International Conference onInteractive Collaborative Learning (ICL), 10.1109/ICL.2 012.6402183,Villach, Austria.[2] Abdul Majid, M., Huneiti, Z. A., Balachandran, W., & Bala rabe, Y .(2013) MATLAB as a teaching and learning tool for Mathematic s: Aliterature review. International Journal of Arts and Scien ces, 6(3), 23-44.[3] Brake, M. L. (2007) MATLAB as a Tool to Increase the Math Se lf-Condence and the Math Ability of First-Year Engineering Te chnologyStudents. The Scholarship of Teaching and Learning at EMU: V ol. 1,Article 5.[4] Chen, J., Kolmos, A., & Du, X. (2021). Forms of implementa tion andchallenges of PBL in engineering education: a review of lite rature.European Journal of Engineering Education, 46(1), 90-115.[5] Cretchley, P., Harman, C., Ellerton, N., & Fogarty, G. (2 000) MATLABin Early Undergraduate Mathematics: An investigation into the Effectsof Scientic Software on Learning. Mathematics Education R esearchJournal, 12(3), 219-233.[6] Hadgraft, R. G., & Kolmos, A. (2020). Emerging learning e nvironmentsin engineering education. Australasian Journal of Enginee ring Educa-tion, 25(1), 3-16.[7] Hernandez-de-Menendez, M., & Morales-Menendez, R. (20 19). Tech-nological innovations and practices in engineering educat ion: a review.International Journal on Interactive Design and Manufactu ring (IJIDeM),13(2), 713-728.[8] Hern andez-de-Men endez, M., Guevara, A. V ., Mart ne z, J. C. T.,Alc antara, D. H., & Morales-Menendez, R. (2019). Active le arning inengineering education. A review of fundamentals, best prac tices and ex-periences. International Journal on Interactive Design an d Manufacturing(IJIDeM), 13(3), 909-922.[9] Kamalov, F., Moussa, S., Zgheib, R., & Mashaal, O. (2020, December).Feature selection for intrusion detection systems. In 2020 13th Interna-tional Symposium on Computational Intelligence and Design (ISCID)(pp. 265-269). IEEE.[10] Kamalov, F., Sulieman, H., & Santandreu Calonge, D. (20 21). Machinelearning based approach to exam cheating detection. Plos on e, 16(8),e0254340.[11] Kilicman, A., Hassan, M. A., & Said Husain, S. K. (2010) T eaching andLearning using Mathematics Software The New Challenge. P rocediaSocial and Behavioral Sciences, 8, 613-619.[12] Lorenz, M., R umann, M., Strack, R., Lueth, K. L., & Bol le, M. (2015).Man and machine in industry 4.0: How will technology transfo rm theindustrial workforce through 2025. The Boston Consulting G roup, 2.[13] Maur cio, R. D. A., Veado, L., Moreira, R. T., Figueire do, E., & Costa,H. (2018). A systematic mapping study on game-related metho ds forsoftware engineering education. Information and software technology,95, 201-218.[14] Mezhennaya, N. M. & Pugachev, O. V . (2019) On perception ofcomputer algebra systems and microsoft excel by engineerin g students.Problems on Education in the 21st Century, 77(3), 379-395.[15] Miranda, J., Navarrete, C., Noguez, J., Molina-Espino sa, J. M., Ram rez-Montoya, M. S., Navarro-Tuch, S. A., ... & Molina, A. (2021). The corecomponents of education 4.0 in higher education: Three case studies inengineering education. Computers & Electrical Engineerin g, 93, 107278.[16] Moore, K., & Frazier, R. S. (2017). Engineering educati on for generationZ. American Journal of Engineering Education (AJEE), 8(2), 111-126.[17] Ortiz-Rojas, M., Chiluiza, K., & Valcke, M. (2019). Gam icationthrough leaderboards: An empirical study in engineering ed ucation.Computer Applications in Engineering Education, 27(4), 77 7-788.[18] Puhak, R. I. (2011). Teaching applied Calculus utilizi ng MATLAB,Proceedings of the Twenty-Third Annual International Conf erence onTechnology in Collegiate Mathematics, ISBN 0-321-68984-4 , Copyright(C) 2012 by Pearson Education, Inc.[19] Ramirez-Mendoza, R. A., Morales-Menendez, R., Iqbal, H., & Parra-Saldivar, R. (2018, April). Engineering Education 4.0:pr oposal for anew Curricula. In 2018 IEEE Global Engineering Education Co nference(EDUCON) (pp. 1273-1282). IEEE.[20] Salah, B., Abidi, M. H., Mian, S. H., Krid, M., Alkhalefa h, H., &Abdo, A. (2019). Virtual reality-based engineering educat ion to enhancemanufacturing sustainability in industry 4.0. Sustainabi lity, 11(5), 1477.[21] Strayhorn, T. L. (2006). College in the information age : Gains associatedwith students use of technology. Journal of Interactive On line Learning,5(2), 143-155.[22] Thabtah, F., Kamalov, F., & Rajab, K. (2018). A new compu tationalintelligence approach to detect autistic features for auti sm screening.International journal of medical informatics, 117, 112-12 4.[23] Van den Beemt, A., MacLeod, M., Van der Veen, J., Van de Ve n,A., van Baalen, S., Klaassen, R., & Boon, M. (2020). Interdis ciplinaryengineering education: A review of vision, teaching, and su pport. Journalof engineering education, 109(3), 508-555.','PDF_1706923558.pdf','2022-07-11 00:00:00.000000'),(101,'How to Teach Software Modeling','To enhance motivation of students to study software engineering, some way of ﬁnding balance between the scientiﬁc aspect and the practical aspect of software engineering is required. In this paper, we claim that teaching multiple software modeling techniques from a uniﬁed viewpoint is a good way of obtaining the balance and attracting the students’ interest as well.','software modeling, software engineering education, UML','How to Teach Software ModelingTetsuo TamaiGraduate School of Arts and SciencesThe University of Tokyo3-8-1 Komaba, Meguro-kuTokyo 153-8902, Japantamai@acm.orgABSTRACTTo enhance motivation of students to study software engineering,some way of nding balance between the scientic aspect and thepractical aspect of software engineering is required. In this paper,we claim that teaching multiple software modeling techniques froma unied viewpoint is a good way of obtaining the balance andattracting the students interest as well.Categories and Subject DescriptorsK.3.2 [ Computers and Education ]: Computer and InformationScience Education computer science education ; D.2.1 [ SoftwareEngineering ]: Requirements/Specication modelingGeneral TermsDesignKeywordssoftware modeling, software engineering education, UML1. INTRODUCTIONSoftware engineering education at universities faces a commonproblem; that is regular students do not usually have experience ofdeveloping software for practical use and thus are not motivated forsoftware engineering aiming at high quality software productionby a project team or a persistent organization. Software projectsconducted by students simulating real scale software developmentmay help enhance students motivation, although it requires a lot ofefforts to prepare such projects and manage them.Another way of solving this problem is to teach those who al-ready have real experience in industry. In our case, there are cur-rently ve Ph. D. students under the authors supervision who areworking at companies as well as doing research in our lab. Asa by-product, interactions between the part-time students and theother regular students stimulate each other, particularly enlighten-ing the regular students to practical software issues. However, toomuch emphasis on practicality may bring negligence to science andCopyright is held by the author/owner.ICSE05, May 1521, 2005, St. Louis, Missouri, USA.ACM 1-58113-963-2/05/0005.technology and may generate anti-intellectualism. A good balancebetween the scientic aspect and the practical aspect of softwareengineering should always be pursued.In our view, teaching various software modeling techniques is agood way to achieve balanced software engineering education. Itis needless to say that model is a key concept and modeling is anessential skill in software engineering. There are a variety of mod-eling techniques; some are intuitive and quite accessible to novices,while some are highly sophisticated and attract theory oriented stu-dents and researchers.In this paper, we would like to show that it is effective to teachmultiple modeling techniques from a unied viewpoint. It is basedon our experience of teaching software engineering courses at sev-eral universities in Japan. Recently, the author published a textbookon software engineering, specically focused on software model-ing (unfortunately, it is written in Japanese)[1]. The book coversthe whole area of software engineering, including design, testingand evolution but the modeling part has a role of attracting inter-ests of intelligent students, who may not have much experience indeveloping real scale software systems. It also gives a consistentviewpoint penetrating through various techniques employed in dif-ferent stages of software engineering.2. MODELING TECHNIQUESIn software engineering, models are used for various purposes,e.g. life cycle model, process model, project model, product model,quality model, domain model, requirements model, design model,object model, data model, etc. In the following, we basically focuson requirements and design models but most of the discussions willhold for other kinds of models.Teaching modeling is almost equal to teaching abstraction. Mod-els are constructed through capturing the crucial properties andstructure of the target, abstracting away irrelevant details. Thus,learning how to model is a good training for mastering abstraction.2.1 Graph Representation of ModelsMany software models are represented with diagrams. Wide ac-ceptance of UML symbolizes the trend that diagrams are often pre-ferred to textual languages. Among many types of diagrams, graphstructured diagrams are by far the most widely used. The reasonsmay be as follows.1. A most fundamental way for human mind to understand theworld is by regarding it as consisting of a set of conceptualunits and a set of relations between them. Conceptual unitscan be naturally illustrated with boxes or circles or whateverclosed gures and relations can be illustrated with lines or ar-rows connecting such gures, corresponding to vertices andedges of graphs, respectively.609 2. It is easy to draw graph structured diagrams by hand or withdrawing tools.3. Concepts and algorithms of the graph theory are availableand often useful in analyzing models represented by graphs.A typical example is reasoning on transitive relations by trac-ing along paths of graphs. Also, the concept of subgraph ishighly useful in decomposing higher-level models or cluster-ing lower-level models.Accordingly, a number of models share the same structure ofgraphs. Table 1 shows graph structures of some typical models.Table 1: Graph structures of typical modelsmodel vertex edgeData ow process data owER entity relationshipState transition state transitionJSD process data stream connectionstate vector connectionActivity activity control owPetri net place, transition re and token ow2.2 Commonality and Difference betweenModelsIt is pedagogical to let students notice the common structureshared by a number of models. However, the apparent resemblanceoften causes confusion. Such confusion can be observed not onlyin software modeling graphs but in many diagrams found in dailynewspapers, magazines, reports, proposals and other documents. Itis often the case that one vertex denotes a type of things and an-other denotes quite a different type on the same diagram or onetype of edges co-exist with edges with different meaning. Thus,it is important to make students consciously aware the differencesbetween different models. We often experience that when we letstudents draw data ow diagrams who appear to have understoodthe data ow model perfectly, the diagrams turn out to be some-thing like control ow graphs.To show the difference, it is instructive to categorize models rep-resented by graphs. Basically, there are two categories.1. Static models:An edge connecting vertex A and vertex B represents a rela-tion between A and B. When the edge is undirected, it meansA and B are in some relation and when directed, it meansA has a relation with B. Typical examples include entityrelationship model, class diagram and semantic network.2. Dynamic models:An edge from vertex A to B denotes a move from A to B.The edge in this case is always directed. There are two sub-categories:(a) The case where a view of control moves from A to B.Examples are control ow model and state transitionmodel.(b) The case where data or objects ow from A to B. Exam-ples are data ow model, work ow model, and trans-portation ow model.Static models and dynamic models may not be easily confusedbut confusion between different dynamic models are often observed,e.g. data ow and control ow or state transition and activity tran-sition. Since graphs are intuitively understandable, their semanticsare apt to be understood ambiguously or misunderstood.3. UMLUML diagrams can also be viewed in terms of graph structures.Table 2 shows graph structures of ve UML diagrams.Table 2: Graph structures of UML diagramsdiagram vertex edgeclass diagram class generalization,composition,associationstate machine state transitionactivity diagram activity control owcollaboration diagram object message owsequence diagram message message owanchor pointIt is usually not desirable to teach UML per se. UML is a col-lection of miscellaneous diagrams and its specication is continu-ously changing. For the pedagogical purpose, UML had better beregarded as a catalogue of analysis and design know-how collectedaround diagrammatic representations. Diagrams should be selectedaccording to the policy of how to teach modeling methods.Each UML diagram contains overly rich constructs, which some-times blur the essential property of the model. For example, theactivity diagram is essentially a control ow diagram but it also in-cludes a notation for data ow description. From the stance of em-phasizing differences between various models, it is not appropriateto include such ad hoc constructs. By the same token, the collab-oration diagram (, renamed to communication diagram in UML2) is explained to have the equivalent semantics as the sequencediagram. But if that is the case, signicance of the collaborationdiagram is considerably limited. The author prefers to regard it asshowing collaboration relations between objects, integrating a setof different sequence diagrams.4. CONCLUSIONSoftware modeling is important by itself but teaching modelingin the software engineering course has at least two additional mean-ings. One is to give a birds-eye view to the whole software engi-neering through the standpoint of modeling technology. The otheris to attract interest of good students who may not have much expe-rience in developing a real-scale software but possess intelligenceand will to attack complexity of modern software construction.5. REFERENCES[1] T. Tamai. Foundations of Software Engineering . IwanamiShoten, Tokyo, Japan, 2004. in Japanese.610 ','PDF_1706927813.pdf','2019-03-15 00:00:00.000000');
/*!40000 ALTER TABLE `articles_article` ENABLE KEYS */;
UNLOCK TABLES;
/*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;

/*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
/*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
/*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
/*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
/*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
/*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
/*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;

-- Dump completed on 2024-02-03  4:13:18
